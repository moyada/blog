---
title: 响应式编程
categories: 随笔
date: 2018-05-21 12:15:29
tags:
---

# 响应式编程
响应式编程(Reactive)是一种新的编程风格，其特点是异步或并发、事件驱动、推送Push机制以及观察者模式的衍生，强调积极主动。
为了确保固定且正确地用户体验，迅速对所有用户做出反应。

* react to events 对事件立即反应
事件驱动的自然特性使的反应能够立即加载实施，通过避免对共享资源的争用实现可扩展性。

* react to failure 对失败立即反应
在任何级别都可以建立一个能够实现失败恢复的弹性系统。

* react to users 对用户立即反应
无论任何负载，值得荣耀的响应时间。


# 响应式的四大原则

1. Event-Driven事件驱动，异步非堵塞，驱动架构是响应式系统的根基。

2. Scalable可伸缩扩展，松耦合，可组合的，分布式的。

3. Resilient弹性，失败恢复。

4. Responsive响应式，是系统的目标，必须能有响应，哪怕错误。

# 事件驱动:Event-driven

基于异步通信的应用程序实现了松耦合的设计，好过于纯粹基于同步的方法调用。发送方和接受方可以实现调用，不要关心事件是如何传播的细节，通过接口实现通信。这就易于延伸，发展和维护，带来更多的灵活性，并降低了维护成本。

由于异步通信的接受人可以在事件发生时或收到一条消息之前保持休眠状态，事件驱动event-driven的方法可以有效地利用现有资源，让多个收件人可以共享一个硬件线程。相比基于同步的传统应用程序，一个非阻塞的应用程序在重负载下可以拥有更低的延迟和更高的吞吐量，这将导致更低的运营成本，提高了资源利用率以及良好的终端用户体验。

在一个事件驱动的应用程序中，组件彼此交互是通过离散事件的生产者和消费者( production/consumption )。这些事件是以异步和非阻塞的方式发送和接收的。事件驱动的系统往往依靠推而不是拉或投票表决，即他们是在有消息时才推送数据给消费者，而不是通过一种浪费资源方式：让消费者不断地轮询或等待数据。

* 异步发送事件：也被称为消息传递意味着应用程序设计于高并发，能够无需改动利用多核硬件。任何一个CPU内核都是能够处理任何消息事件，这导致并行的机会急剧增加。

* 非阻塞：意味着应用程序在故障等突发情况下任何时候都能实现响应。而对于这一切所需的资源响应，例如CPU，内存和网络都不会发生垄断。因此，它可以同时兼具更低的延迟，更高的吞吐量和更好的可扩展性。

传统的服务器端架构是依赖于在一个单独的线程中共享可变状态和实现阻塞操作。这样的系统在满足不断变化的需求时难以扩展伸缩，共享可变状态需要同步，它引入了附带的复杂性和不确定性，使得程序代码很难理解和维护。把一个线程通过阻断方式使用实际是限制了资源，并带来高昂的唤醒成本。

事件的产生和处理的解耦，能够让运行平台更关注同步细节以及事件是如何跨线程分发的，当程序抽象抬升到业务流程级别，你考虑的是事件如何传播以及如何通过系统组件之间进行交互，而不是摆弄周围的低级初始设备如线程和锁。

事件驱动的系统使组件和子系统之间的松耦合。这是可扩展性和弹性的先决条件之一。通过消除复杂和强大的组件之间的依赖，事件驱动的应用可以通过影响最小的方式扩展现有的应用程序。


# 消息驱动架构中的弹性(Message-driven resiliency)
在一个消息驱动的内核之上构建应用的美妙之处在于你自然地得到了很多有价值的构造模块。

* 隔离性(Isolation)
隔离性是一个自愈(self-heal)的系统所需要的。当隔离性在被恰当地使用，我们可以依据一些因素把不同类型的工作进行分离，比如失效的风险、不同的性能、CPU和内存的使用，等。一个isolation的组件的失效并不会影响整个系统的responsiveness, 并且给予了失效的那个系统一个被治愈的机会。

* 位置透明性(Location transparency)
使得我们与不同集群结点上的不同进程间的通信就像与同一个VM的进程内通信一样。

* 划分单独的错误频道

一个精心设计的分离的错误信息通道使得我们可以把错误信号重定向到其它地方，而不是抛回到调用者面前。（注：这个作用应该类型于Akka中的event stream这种东西，使得某些失败的信息可以被订阅，使得不光在当前是调用了某个失败组件的组件可以知道它失败了，而是所有相关的组件都可以了解到这个情况，便于他们即是作出响应）

这些因素帮助我们把健壮的错误处理和容错合并进我们的系统中。Akka的supervisor hierarchies的实现展示了这点。

消息驱动架构提供的这些核心的构建模块有助于resiliency，进而有助于responsiveness——不仅在理想情况下，而且在各种并非理想的、现实世界的情况下。

# 弹性
弹性有以下含义：

物质或物体拥有形状上弹回的能力。
从困难中恢复的能力。
　　
在一个reactive应用中，应变能力不是一个可有可无的东西，而是从一开始就成为设计的一部分。故障应对在编程模型中构建时就第一面对，这就导致应用程序是高度宽容失败并在运行时能够提供手段愈合修复自己。传统的故障处理是不能做到这一点，因为它是要么防御小，要么过于激进，你必须在系统的一个个地方去处理异常Exception(banq:将你的方法到处加上try{}catch)。

为了管理失败，我们需要一种方法来隔离它，使它不会扩散到其他健康的部位，并能观察它，从失败的上下文以外的安全点对其进行管理。如果其中一个出现故障，不影响其他的。这可以防止级联故障的经典的问题，并允许隔离管理问题。

事件驱动的松散耦合提供了组件在失败下可以抓获完全隔离的上下文场景，作为消息封装，发送到其他组件时，在具体编程时可以检查错误比如是否接受到，接受的命令是否可执行等等，并决定如何应对。

这种方法创建了一个能让业务逻辑保持清洁的系统，显式的隔离分开处理Exception的有利于观察，管理和配置，并能让系统自行愈合，并自动恢复。这类似在一个大公司内，将一个问题逐步向上升级，直到达到有权力来处理它的水平。

这个模型的美妙之处在于它是纯粹的事件驱动，它是reactive组件和异步事件，意味着在分布式环境中具有在本地一台服务器范围内相同的语义。

# 伸缩性
弹性和伸缩性可以协力帮你创建具有一致性的响应式应用。
一个具有伸缩性的系统，可以在多负载的情况下轻松的升级，并且保证服务的响应性。
在网上买东西的骚年都清楚一个事实：当你的东西热销的时候，流量会很大。通常情况下，除了刻意的网络攻击。
正常情况大量流量的操作是被允许的。当出现有大量的流量需要给你支付金额。
因此你要如何处理突如其来的任持续增长的请求？
首先选择好方案，第二选择好语言工具来实现你的方案。
然而大多数的程序员认为应该怎么做是按照语言和框架所推崇的。大多数人因为工具的约定，让他们难以去有更多的思维，来决定如何处理更多的情况。因为一些工具致使他们无法站在自己的环境下做出决定。
如果你在技术层面有独立的分析能力以及设计原则，那么你已经远远领先了他们。

# 基于线程并发的限制
选择一种并发模型的框架是很重要的一个技术决策。有两种类型的高级并发模型：

* 传统的基于调用栈和内存共享的线程并发模型。
* 消息驱动模型
一些流行的MVC框架例如Rails就是基于线程的并发模型。这种类型的框架特点包括：
* 共享可变状态
* 一个线程处理一个请求
* 并发的访问可变的变量和对象实例时通过管理锁和其他的复杂同步机制。
结合以上的特性以及动态类型，像ruby这样的解释性语言，你会很快的达到性能以及伸缩性的瓶颈。
对于任何一种语言根本上也是一样的，毕竟它的核心实现是一个脚本语言。


# 伸缩？是横向还是纵向？
让我们考虑一下几种伸缩的方式。

* 纵向伸缩
涉及单独一个CPU或者服务器，通常会需要资金的支持，升级硬件。

* 横向伸缩
涉及分布式计算跨越集群，可以在不增加设备成本的情况下（比如说可以用云平台），由于你的系统是基于时间和空间的概念，很难实现。

正如之前我们说说，异步边界解耦了空间和时间，让我们的更好的实现横向伸缩，这样也称之为弹性。
横向伸缩的优势是可以更充分的利用好服务器资源，而且弹性可以根据你的需求来增加，纵向伸缩的能力是响应式应用的最终目的。
响应式应用很难基于多线程的框架构造，因为横向扩展一个基于共享可变状态、多线程和锁是非常困难的。开发者需要考虑在单机的情况下利用好多核的机器，还需要在集群里充分利用。是
共享可变状态会增大横向伸缩的实现难度。学过多线程的人大家都清楚共享变量在多个不同的线程里会出现线程安全的问题。


# 消息驱动
消息驱动架构是响应式程序的基础。消息驱动可以用事件驱动，基于actor，或者混合二者实现。

一个事件驱动系统通过监控一个或者多个观察者实现。它不同于命令式的程序设计，它不会因为调用会阻塞程序而等待直到它响应调用的结果。
事件不会指向同一个对象，而是根据监听它的变化，这有一定的影响，接下来让我们。

基于Actor的并发模型是基于消息传递架构的衍生，消息会指向一个接收者 - 一个actor。
消息也许会穿越线程边界，也可能在不同的物理机上之间传递到另一个actor的信箱。Actor的弹性特性可以按照需求横向伸缩
actors可以在分布跨越在网络里，如果他们可以通过相互通信，共享同样的内存。

消息以及事件的主要区别在于消息可以指向性的，事件是触发性的。消息有一个明确的目标，然而事件可能有多个观察者。

# 事件并发模型
传统的应用程序采用命令式的风格开发 - 一系列有步骤的操作 基于当前的调用栈。调用栈的主要目的是保持跟踪子程序(routine)的调用者，然后执行子程序(routine)，会阻塞当前的主线程，等待子程序的执行，最终会随着子程序的返回值把控制权返回当前调用者的线程。
从表面上来看，事件驱动的应用程序并不关注调用栈，它只是触发事件。事件也许会被编码成消息放置在用来监听多个观察者的队列里。事件驱动和命令方式的两者的区别在于一个调用者是非阻塞的，一个则是需要阻塞线程等待响应结果。
事件循环虽然可能是单线程的，但是并发仍然是可行的。可以通过调用子程序实现相关业务，当收到一个请求的时候会有事件循环的线程处理（有时候事件线程是一个单独的线程），而不是收到请求之后阻塞线程指导处理完之后才返回结果。

基于事件驱动架构的可能会引起callback hell影响代码的可维护性。发生callback hell的原因是，消息的接收方是基于异步回调传递的，而不是直接的通过引用找到的。
callback hell又被称作the Pyramid of Doom，它的解决方案在于代码的编写，然而这样可能会造成难于调试。

# 实时响应
这是迅速回应或作出适当的反应的意思， 我们使用这个词在一般意义上不应该与响应的网页设计混淆，后者主要是指CSS媒体查询和渐进增强。

响应的应用程序是实时的，耐看的，丰富的和协作。企业与他们的客户建立一个开放的和持续的对话，欢迎他们通过响应的互动体验。这使得它们更有效率，建立连接，并配备解决问题和完成任务的感觉。一个例子是，在使用谷歌Docs 时，几个用户能够编辑文档协作，能实时地让他们看到彼此的编辑和注释的结果。

对事件作出响应的应用程序，需要及时去做(just do it)，即使存在故障情况。如果应用程序在长时间不做出回应，称为延迟，这个系统实际是不可用的，因此不能被视为弹性。

当然并非所有应用如武器或医疗监控系统这样对实时要求如此高，但是通常他们在运行一段时间后出现迅速下降的性能，才可以从他们偏离了一点响应限制看出(banq: windows越用越慢)，假如是金融交易应用程序可能会失去目前的交易没有及时回应。

# 背压(back pressure)
Reactive流的主要特征是“back pressure后压”：也就是说，系统会在它的请求buffer被充满时，将其推送会给发送者，让发送者稍后再试，或者使用其他接收器，这就能确保发送者和接收者之间的管道不会被充满，这样才有机会获得一个响应式系统。

