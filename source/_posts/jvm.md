---
title: Java虚拟机整理
categories: java
date: 2018-05-19 19:15:57
tags:
---

# JVM(Java虚拟机)
JVM是JRE包含的Java程序运行所需的程序，屏蔽各种硬件和操作系统的内存访问差异，通用一份jar包。
另外，JVM还提供了内存管理的功能，使得开发人员无需关心底层内存如何管理。

> https://www.youtube.com/watch?v=ZBJ0u9MaKtM

# 类加载机制
Java虚拟机的类加载有加载(load)、连接(link)、初始化(initialize)三个步骤

当一个类被实例化时或者类中静态方法被调用时将进行类加载

## 加载
将不同的类数据源以字节码的形式加载到内存中以供类加载器使用，数据的来源可以是jar包、class类、网络数据，一个类数据有且只有一个存在于一个类加载器中。

正常的类加载是以双亲委任机制，不同的类加载器是以继承的方式连接的，当通过某个类加载器加载一个类数据时，当这个类加载器存在父类加载器时，那么它会先从父类加载器中寻找类数据，不存在再在自身中寻找，并且父类也是遵循这个机制。

> Tomcat的类加载器重写了这个加载机制，会优先在自身中查找，这跟Tomcat所加载类的所在位置有关。

## 连接
连接包含了验证、准备、解析三个步骤

1. 验证确保了类加载的正确性，它校验了字节码数据是符合Class类规范，常量类型是否支持，语义分析，分析数据流和控制流校验程序语义，符号引用校验。

2. 准备环节是为一个类的静态域分配内存空间，并赋予零值。

3. 解析负责转化类中的符号引用，将类引用转换为直接引用，将类中的常量值转换为常量池中引用。

> 如果类字段的字段属性中存在`ConstantValue`属性，即同时被`final`和`static`修饰，那么在准备阶段变量就会被初始化为属性所指定的值。

## 初始化
对类的静态域赋予正确的初始值，执行静态代码块为赋值静态域。

## 异常

* ClassNotFoundException
这种错误是发生在加载环节，当一个类在双亲委任机制中无法获取到时，便会抛出此异常。常见情景是依赖包的冲突。

* NoClassDefFoundError
这个错误主要是发生在连接环节的解析中，当一个类的静态域引用至另一个类中的属性，而这个类无法获取时，那么虚拟机就会抛出此异常。

# 运行时数据区域

Java虚拟机在运行程序的过程中把内存数据划分为不同的区域

## 线程隔离的(指令区)

* 程序计数器：指向线程下一个执行的指令的地址(`本地指针`或者`起始指令的偏移量`)，当执行的是本地方法时为undefined。
许多操作都需要依赖程序计数器来完成，例如在时间片抢占后切换线程能够恢复到正确的位置。

* 虚拟机栈：包含了线程生命周期的方法调用，一个方法调用即为一个栈帧，以栈形式顺序入栈。
存储当前线程运行方法所需要的局部变量表（基本数据类型、对象引用）、操作数栈、动态连接、方法返回地址。

* 本地方法区：与虚拟机栈作用相似，区别是执行Native方法。

## 线程共享的(数据区)

* 方法区／元空间(MetaSpace)：存放类信息、静态域数据、类编译期间生成的各种字面量和符号引用、JIT编译后的机器码、动态代理产生的数据，使用本地内存存储，几乎不会被回收。

* 堆(Heap)：运行时常量池、对象实例域，是垃圾收集管理的主要区域。可分为新生代、老年代。

* 直接内存：用于NIO数据交换的内存空间，只受实际内存及JVM参数限制。

## 内存溢出
内存溢出是由于虚拟机空间分配失败所导致的致命性错误。

* 方法栈(StackOverFlowError)
常见原因有递归或大循环调用方法导致栈帧数量过多、线程内定义大量的本地变量。

* 堆(OutOfMemoryError)
常量池溢出、线程持续占有对象都将可能导致堆溢出。

* 方法区(OutOfMemoryError)
主要原因为创建大量的类，并且未来得及卸载。

# 执行引擎

## 解释器(Interpreter)
解释字节码，执行相应的命令

## 分析器(Hotspot profiler)
将频繁调用的热点方法编译成与本地平台相关的机器码

## JIT(即时编译器)
优化解释器，将字节码翻译成本地平台相关的机器码执行
常见的JIT有C1、C2，在Java10引入Graal

常见的JIT优化手段有

* 公共子表达式消除
当一个大表达式已经被计算过后，再次出现已经包含了的表达式则不必重新计算，直接用结果代替。

* 数组边界检查消除
消除大循环体内对元素越界检查

* 方法内联
将频繁调用方法替换为调用方法代码

* 逃逸分析
当开启了标量替换(-XX:+EliminateAllocations)和逃逸分析(-XX:+DoEscapeAnalysis)后，会对线程栈内的对象进行分析，将只存活于栈帧内的可分解对象进行基础类型数据替换处理。

* 同步消除(-XX:+EliminateLocks)
在开启逃逸分析和-server模式后，将会对无多线程竞争的锁进行消除。

* 优化技术

编译器策略：延迟编译，分层编译，栈上替换，延迟优化，程序依赖图表示，静态单赋值表示。

基于性能监控的优化技术：乐观空值断言，乐观类型断言，乐观类型增强，乐观数组增强，裁剪未被选择的分支，乐观的多态内联。分支频率预测，调用频率预测

基于证据的优化技术：精确性推断，内存值推断，内存值跟踪，常量折叠，重组，操作符退化，空值检查消除。类型检测退化，类型检测消除，代数化简，公共子表达式消除

数据流敏感重写：条件常量传播，基于六承载的类型缩减转换，无用代码消除

语言相关的优化技术：类型继承关系分析，去虚拟机化，符号常量传播，自动装箱，消除逃逸分析，锁消除，锁膨胀，消除反射

内存及代码位置交换：表达式提升，表达式下沉，冗余存储消除，相邻存储合并，交汇点分离

循环变换：循环展开，循环剥离，安全点消除，迭代分离，范围检查消除

局部代码调整：内联，全局代码提升，基于热度的代码分离，Switch调整

控制流图变换：本地代码编排，本独代码封包，延迟槽填充，着色图寄存器分配，线性扫描寄存器分配，复写聚合，常量分裂，复写移除，地址模式匹配。指令窥孔优化，基于确定有限状态机的代码生成

* Graal[jdk10]
启动方式 -XX:+UnlockExperimentalVMOptions -XX:+UseJVMCICompiler

## GC(垃圾收集器)

Java虚拟机在运行时会产生大量的对象，有些对象将不会再被使用，为了使内存不被这些无用的对象占用，垃圾收集器就需要分析出已经死亡的对象，将其所用空间回收。

虚拟机从一部分称为`GC Roots`的节点开始搜索引用链，找出存活的引用(并非特指对象)，对其余对象则为无用执行finilize()方法，标记为虚引用，并放入一个F-Queue队列，稍后对队列中的对象再次进行分析，判断是否与引用链有连接，如果没有则垃圾收集器对其进行清除释放空间。

* CMS(Concurrent Mark Sweep)

* G1(Garbage-First)
G1是将内存空间以块进行划分分配空间的，目的是减少内存中碎片的产生。优先回收大垃圾的回收机制。它维护了一个空闲空间列表。

虚拟机在分配空间时会选定一个Region(TLAB将分别指定一个Region)，当Region的剩余空间不足以分配对象或者小于最小可空间时，将重新质地ing

初始并发标记

最终并发标记

年轻代
年轻代+老年代
混合模式

如果在并发标记阶段发现一个类下已无实例存活时，将卸载此类。

如果分配一个对象大于Region大小的一半，将会分配一个Humongous Region直接进入老年代，这个Humongous Region的大小将为能容纳对象的最小Region空格倍数。

### stop the world(STW)
在初始标记、最终标记、标记过程、卸载类阶段将会发生一次STW停顿。

> https://www.zhihu.com/question/53613423/answer/135743258

# MetaSpace
源自JRockit，在Java8与Hotspot合并，将native method area概念加入Hotspot，由此得来MetaSpace，替换原有的PermGen，MetaSpace的容量受可用的本地内存限制。

MetaSpace的空间是以块(Chunk)为单位，这个块的大小取决与申请空间的类加载器类型。

当类加载器加载类时，从块分配器中获取一份块内存空间存在类元数据，并映射此地址。

元数据的生命周期是与类加载器一致的，但一个类加载器死亡时，相对应的元数据也被销毁，释放其块空间。

由于每个类加载器申请的块大小不一致，Metaspace VM也还未使用压缩技术，这就容易导致内存碎片的产生。

# 内存模型(JMM)

heap根据空间利用率、垃圾回收存活年龄分为新生代、老年代。

## 新生代
新生代又可细分为 Eden空间、S0空间(From Survivor)、S1空间(To Survivor)
Eden Space中存在线程私有的空间TLAB，是每个线程的缓冲区，存放一些用过即丢弃的对象。

## 老年代
当新生代的对象超过设定年龄，或者同龄对象达到幸存区的一半，这些对象将被划入老年代(Old Space)。
只有当老年代空间不足分配发生Full GC时，才会对老年代的数据进行回收。

## TLAB

当大量线程申请空间时，JVM需要对并发操作保障不会发生指针碰撞，这样便增加了复杂性，降低性能。

因此，在jdk1.6以后便引入了TLAB技术。

TLAB全称ThreadLocalAllocBuffer，是在线程初始化的时候在堆中新生代申请一块线程私有的分配空间(允许所有线程访问)，减少同步开销，使用参数 `-XX:UseTLAB` 开启。

> https://www.jianshu.com/p/cd85098cca39

## PLAB
promotion LAB，用于老年代，与TLAB类似功能。

# volatile

* volatile原语保障了多线程下使用共享变量的原子性、可见性、有序性。

* 其原理是利用主内存中存放数据，其余线程读取数据时，从主内存中获取；修改数据时立即刷新到主内存，并使得其余工作内存数据无效。

* 可使数据操作通过内存屏障来达到了简单操作的原子性，由于volatile只是读取了相对新值(读取的一刻，其他线程也有可能改变值)，所以复合操作无法达到原子性。

* JVM为了保证volatile域的可见性(happens-before)，会在编译时对指令前后都加入lock前缀内存屏障指令，使得不会将后面的指令重排序到内存屏障之前的位置。
1. 当第二个操作是volatile写时，不管第一个操作是什么，都不能重排序。这个规则确保volatile写之前的操作不会被编译器重排序到volatile写之后。
2. 当第一个操作是volatile读时，不管第二个操作是什么，都不能重排序。这个规则确保volatile读之后的操作不会被编译器重排序到volatile读之前。
3. 当第一个操作是volatile写，第二个操作是volatile读时，不能重排序。

* 由于volatile域的可见性，也可用来完成轻量锁的实现、线程的完成



