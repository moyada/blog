---
title: 浅入深出
categories: java
date: 2017-12-25 12:56:19
tags:
---

# Java

## 基础

### 面向对象的特征

* 封装
也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。

* 继承
使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。

* 多态
允许你将父对象设置成为和一个或更多的他的子对象，允许将子类类型的指针赋值给父类类型的指针，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。


### final, finally, finalize 的区别

* final
final用于控制成员、方法或者是一个类是否可以被重写或者继承等功能
如果类被声明为final，意味着它不能再派生出新的子类，不能作为父类被继承。将变量或者方法声明为final，可以保证他们在使用中不被改变。
如果方法被声明为final，如果这个方法足够小并且在运行时频繁调用，那么JIT将会利用方法内联(inlining)将调用该方法的位置直接以代码替换。

* finally
finally结构使代码总会执行，不关有无异常发生。
一般是用于异常处理中，提供finally块来执行任何的清楚操作。

* finalize
在垃圾收集器将对象从内存中清理出去之前做必要的清理工作。
这个方法是由垃圾收集器在确定这个对象没有被引用是对这个对象调用的。

### int 和 Integer 有什么区别

int是基本类型，Integer是包装类型，二者可以通过自动拆箱／装箱进行转换。
基本类型的数据是直接存储在内存中的，而Integer则是以引用方式存储。
Integer内部维护了一个不可变的int数值，除此之外还有许多相关的数学操作方法。

### 重载和重写的区别

方法重载是让类以统一的方式处理不同类型数据的一种手段。多个同名函数同时存在，具有不同的参数个数/类型。

父类与子类之间的多态性，对父类的函数进行重新定义。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)，子类函数的访问修饰权限不能少于父类的。
子类覆盖父类的方法时，只能比父类抛出更少的异常，或者是抛出父类抛出的异常的子异常。
子类方法的访问权限只能比父类的更大，不能更小。


### 抽象类和接口有什么区别

接口和抽象类都是继承树的上层，他们的共同点如下：
1. 都是上层的抽象层。
2. 都不能被实例化
3. 都能包含抽象的方法，这些抽象的方法用于描述类具备的功能，但是不比提供具体的实现。

他们的区别如下：
1. 抽象类中可以写非抽象的方法，接口中只能有抽象的方法（java8中可以存在抽象方法和默认方法）。
2. 接口中的变量只能是static、final声明的、方法默认修饰符是public(java9可以有私有方法)。
3. 一个类只能继承一个直接父类，这个父类可以是具体的类也可是抽象类；但是一个类可以实现多个接口。
4. 抽象类可以有构造器，而接口不能有构造器。
5. 继承抽象类表示“从属”关系，实现接口表示“组合”关系
6. 接口比抽象稍微慢的，因为它需要时间去寻找在类中实现的方法。

Java语言中类的继承是单继承原因是：当子类重写父类方法的时候，或者隐藏父类的成员变量以及静态方法的时候，JVM使用不同的绑定规则。如果一个类有多个直接的父类，那么会使绑定规则变得更复杂。为了简化软件的体系结构和绑定机制，java语言禁止多继承。
接口可以多继承，是因为接口中只有抽象方法，没有静态方法和非常量的属性，只有接口的实现类才会重写接口中方法。因此一个类有多个接口也不会增加JVM的绑定机制和复杂度。


### 说说反射的用途及实现

1. 在运行时判断任意一个对象所属的类
2. 在运行时构造任意一个类的对象
3. 在运行时判断任意一个类所具有的成员变量和方法（通过反射甚至可以调用private方法）
4. 在运行时调用任意一个对象的方法
5. 因为反射的动态性，所以最常见的就是开发各种通用框架，例如Spring的DI/IoC

### 说说自定义注解的场景及实现

开发可配置框架，如登陆拦截、定时任务、数据库源管理。
可以通过AOP（动态代理机制）和反射给包含注解方法添加切面。

### JDBC 流程

1. 向DriverManager类注册驱动数据库驱动程序

2. 调用DriverManager.getConnection方法， 通过JDBC URL，用户名，密码取得数据库连接的Connection对象。

3. 获取Connection后， 便可以通过createStatement创建Statement用以执行SQL语句。

4. 有时候会得到查询结果，比如select，得到查询结果，查询（SELECT）的结果存放于结果集（ResultSet）中。

5. 关闭数据库语句，关闭数据库连接。

### MVC 设计思想
MVC是三个单词的首字母缩写，它们是Model（模型）、View（视图）和Controller（控制）。
这个模式认为，程序不论简单或复杂，从结构上看，都可以分成三层。

* 最上面的一层，是直接面向最终用户的"视图层"（View）。它是提供给用户的操作界面，是程序的外壳。
* 最底下的一层，是核心的"数据层"（Model），也就是程序需要操作的数据或信息。
* 中间的一层，就是"控制层"（Controller），它负责根据用户从"视图层"输入的指令，选取"数据层"中的数据，然后对其进行相应的操作，产生最终结果。

### equals 与 == 的区别

* == 在比较基本数据类型时比较的是值，而在比较引用类型的数据时比较的是引用的地址，即比较两个引用是否指向同一个对象。

* equal() 是java.lang.Object的方法，默认与 == 比较方式相同，可以被程序员重写该方法实现自定义比较方式。
hashCode() 方法给对象返回一个hashcode值。当两个对象相等时，hashcode一定相同，但是反过来不一定成立。

### String、StringBuffer、StringBuilder区别

* String对象一旦创建不可更改，对String的任何操作都不会影响原对象。
* StringBuffer与StringBuilder存储的内容是可以更改的。
* SringBuilder是线程不安全的，StringBuffer带有synchronized关键字是线程安全的。

### 什么是内部类？内部类的作用

定义在一个类的内部的类我们就叫内部类。内部类可以很好的实现隐藏。一般的非内部类，是不允许有 private 与protected权限的，但内部类可以。内部类拥有外围类的所有元素的访问权限，可以实现多重继承，可以避免修改接口而实现同一个类中两种同名方法的调用。

### Comparable和Comparator的不同之处？

Comparable和Comparator接口被用来对对象集合或者数组进行排序。
Comparable接口被用来提供对象的自然排序，我们可以使用它来提供基于单个逻辑的排序。
Comparator接口被用来提供不同的排序算法，我们可以选择需要使用的Comparator来对给定的对象集合进行排序。

### 什么是深拷贝和浅拷贝

* 浅拷贝：

浅拷贝又叫浅复制，将对象中的所有字段复制到新的对象（副本）中。其中，值类型字段(java中8中原始类型)的值被复制到副本中后，在副本中的修改不会影响到源对象对应的值。而引用类型的字段被复制到副本中的还是引用类型的引用，而不是引用的对象，在副本中对引用类型的字段值做修改会影响到源对象本身。

* 深拷贝：

深拷贝将对象中的所有字段复制到新的对象中。不过，无论是对象的值类型字段，还是引用类型字段，都会被重新创建并赋值，对于副本的修改，不会影响到源对象本身。

## 集合

### 为什么Collection不能继承Cloneable和Serializable？

Collection表示一个集合，包含了一组对象。如何存储和维护这些对象是由具体实现来决定的。因为集合的具体形式多种多样，例如list允许重复，set则不允许。而克隆（clone）和序列化（serializable）只对于具体的实体，对象有意义，不能去把一个接口，抽象类克隆，序列化甚至反序列化。所以具体的collection实现类是否可以克隆，是否可以序列化应该由其自身决定，而不能由其超类强行赋予。
如果collection继承了clone和serializable，那么所有的集合实现都会实现这两个接口，而如果某个实现它不需要被克隆，甚至不允许它序列化（序列化有风险），那么就与collection矛盾了。

### List 和 Set 区别

1. List, Set都是继承自Collection接口

2. List有放入顺序，并且允许重复的元素。Set的元素不可重复并且无序（元素虽然无放入顺序，但是元素在set中的位置是有该元素的HashCode决定的，其位置其实是固定的）

3. Set没有索引，List有索引。

4. Set仅仅允许一个null值，List允许多个null值

5. List接口有三个实现类：LinkedList，ArrayList，Vector ，Set接口有两个实现类：HashSet(底层由HashMap实现)，LinkedHashSet

List的元素可重复且无序的，Set的元素不可重复并且有序


### List 和 Map 区别

List有放入顺序,元素可重复

Map元素按键值对存储,无放入顺序

Map被设计为键值对的集合,相当于和Collection一个级别的；Map该集合存储键值对，且要求保持键的唯一性；

### Arraylist 与 LinkedList 区别

1. 因为Arraylist是基于索引的数据结构，它使用索引在数组中搜索和读取数据是很快的。
Array获取数据的时间复杂度是O(1),但是要删除数据却是开销很大的，因为这需要重排数组中的所有数据。

2. 相对于ArrayList，LinkedList插入是更快的。因为LinkedList的内部是以链表的结构存放数据，不需要在数组装满的时候要将所有的数据重新装入一个新的数组，这是ArrayList最坏的一种情况，时间复杂度是O(n)，而LinkedList中插入或删除的时间复杂度仅为O(1)。ArrayList在插入数据时还需要更新索引（除了插入数组的尾部）。

3. 类似于插入数据，删除数据时，LinkedList也优于ArrayList。

4. LinkedList需要更多的内存，因为ArrayList的每个索引的位置是实际的数据，而LinkedList中的每个节点中存储的是实际的数据和前后节点的位置。

### ArrayList 与 Vector 区别

1. ArrayList在内存不够时默认是扩展50% + 1个，Vector是默认扩展1倍。

2. Vector提供indexOf(obj, start)接口，ArrayList没有。

3. Vector属于线程安全级别的，但是大多数情况下不使用Vector，因为线程安全需要更大的系统开销。


### 能否使用任何类作为Map的key？

1. 如果类重写了equals()方法，它也应该重写hashCode()方法。
2. 类的所有实例需要遵循与equals()和hashCode()相关的规则。请参考之前提到的这些规则。
3. 如果一个类没有使用equals()，你不应该在hashCode()中使用它。
4. 用户自定义key类的最佳实践是使之为不可变的，这样，hashCode()值可以被缓存起来，拥有更好的性能。不可变的类也可以确保hashCode()和equals()在未来不会改变，这样就会解决与可变相关的问题了。

### HashMap 和 Hashtable 的区别

HashMap和Hashtable都实现了Map接口，但决定用哪一个之前先要弄清楚它们之间的分别。主要的区别有：线程安全性，同步(synchronization)，以及速度。

1. HashMap允许key和value为null，而HashTable不允许。

2. HashMap是非线程安全的，而Hashtable是synchronized，线程安全的。Java 5提供了ConcurrentHashMap，它是HashTable的替代，比HashTable的扩展性更好。

3. 另一个区别是HashMap的迭代器(Iterator)是fail-fast迭代器，而Hashtable的enumerator迭代器不是fail-fast的。所以当有其它线程改变了HashMap的结构（增加或者移除元素），将会抛出ConcurrentModificationException，但迭代器本身的remove()方法移除元素则不会抛出ConcurrentModificationException异常。但这并不是一个一定发生的行为，要看JVM。这条同样也是Enumeration和Iterator的区别。

### HashSet 和 HashMap 区别

1. HashMap实现了Map接口，HashSet实现了Set接口

2. HashMap储存键值对，HashSet仅仅存储对象

3. HashSet内部维护了一个HashMap，使用add()方法将元素放入map中

4. HashMap中使用键对象来计算hashcode值，HashSet使用成员对象来计算hashcode值

### ConcurrentHashMap 的工作原理及代码实现

ConcurrentHashMap对整个桶数组进行了分段，主干是个Segment数组。Segment继承了ReentrantLock，所以它就是一种可重入锁（ReentrantLock)。在ConcurrentHashMap，一个Segment就是一个子哈希表，Segment里维护了一个HashEntry数组，并发环境下，对于不同Segment的数据进行操作是不用考虑锁竞争的。

* java8开始ConcurrentHashMap不是使用分段锁，改为链表->红黑树，当链表长度大于8则变化为红黑树，当红黑树元素小于8时，则退化为链表

### 队列相关问题

### BlockingQueue是什么？

BlockingQueue是一个队列，在进行检索或移除一个元素的时候，它会等待队列变为非空；当在添加一个元素时，它会等待队列中的可用空间。BlockingQueue接口是Java集合框架的一部分，主要用于实现生产者-消费者模式。我们不需要担心等待生产者有可用的空间，或消费者有可用的对象，因为它都在BlockingQueue的实现类中被处理了。

## 线程

### 创建线程的方式及实现

1. 继承Thread类创建线程类，实现run方法

2. 通过Runnable接口创建线程类，实现run方法

3. 通过Callable和Future创建线程，实现call方法

4. 通过CompletableFuture.supplyAsync创建异步线程，实现Supplier接口

### sleep() 、wait()、join()、yield()有什么区别

* sleep()方法可以让当前正在执行的线程主动让出CPU，进入阻塞状态。
该方法既可以让其他同优先级或者高优先级的线程得到执行的机会，也可以让低优先级的线程得到执行机会。
但是sleep()方法不会释放`锁标志`，也就是说如果有synchronized同步块，其他线程仍然不能访问共享数据。 

* wait()方法则是指当前线程让自己暂时退让出同步资源锁，释放所占有的锁标志，阻塞线程并将当前线程放入对象等待池中。
调用wait()方法的线程必须拥有`锁标志`(在同步方法或同步块中)。
调用了notify()将从对象等待池中移出任意一个线程并放入锁标志等待池中
或notifyAll()方法将对象等待池中的所有线程都移动到该对象的锁标志等待池。 
只有锁标志等待池中的线程可以竞争同步资源锁，进而得到执行。

* yield()使当前线程重新回到就绪状态，能使更高优先级的线程有执行的机会。 

* join()阻塞当前线程，等待调用join方法的线程结束，再继续执行。

### 什么导致线程阻塞？

1. 线程执行了Thread.sleep(int millsecond);方法，当前线程放弃CPU，睡眠一段时间，然后再恢复执行。
2. 线程执行一段同步代码，但是尚且无法获得相关的同步锁，只能进入阻塞状态，等到获取了同步锁，才能回复执行。
3. 线程执行了一个对象的wait()方法，直接进入阻塞状态，等待其他线程执行notify()或者notifyAll()方法。
4. 线程执行某些IO操作，因为等待相关的资源而进入了阻塞状态。比如说监听system.in，但是尚且没有收到键盘的输入，则进入阻塞状态。

### 线程如何关闭？

1. 使用退出标志，使线程正常退出，也就是当run方法完成后线程终止。
2. 使用stop方法强行终止线程（这个方法不推荐使用，因为stop和suspend、resume一样，也可能发生不可预料的结果）。
3. 使用interrupt方法中断线程。

### 同步方法有哪些

1. 同步方法:即有synchronized关键字修饰的方法。由于java的每个对象都有一个内置锁，当用此关键字修饰方法时，内置锁会保护整个方法。在调用该方法前，需要获得内置锁，否则就处于阻塞状态。

2. 同步代码块：即有synchronized关键字修饰的语句块。被该关键字修饰的语句块会自动被加上内置锁，从而实现同步。

3. wait与notify方法保证线程同步。

4. 使用volatile：volatile关键字为域变量的访问提供了一种免锁机制，使用volatile修饰域相当于告诉虚拟机该域可能会被其他线程更新。

5. 使用重入锁实现线程同步：ReentrantLock类是可重入、互斥、实现了Lock接口的锁， 它与使用synchronized方法和快具有相同的基本行为和语义，并且扩展了其能力。

6. 使用局部变量实现线程同步：使用ThreadLocal管理变量，则每一个使用该变量的线程都获得该变量的副本，副本之间相互独立，这样每一个线程都可以随意修改自己的变量副本，而不会对其他线程产生影响。

7. 使用阻塞队列实现线程同步：JavaSE5.0版本中新增的java.util.concurrent包将有助于简化开发。

### synchronized和volatile关键字的区别

1. volatile本质是在告诉jvm当前变量在寄存器中的值是不确定的，需要从主存中读取，synchronized则是锁定当前变量，只有当前线程可以访问该变量,其他线程被阻塞住。
2. volatile仅能使用在变量级别，synchronized则可以使用在变量，方法。
3. volatile仅能实现变量的修改可见性，而synchronized则可以保证变量的修改可见性和原子性。
4. volatile不会造成线程的阻塞，而synchronized可能会造成线程的阻塞。

### synchronized与Lock的区别

1. 同步代码块其实自身是具有自动上锁、自动解锁功能的。Lock锁机制则是手动解锁，手动上锁的
2. 用synchronized修饰的同步代码块还有同步方法是有同步锁对象的。Lock锁机制是没有同步锁对象的。
3. 因为synchronized修饰的同步代码块还有同步方法是具有锁对象的，因此，可以调用notify()、wait()、notifyAll()的方法。但是因为Lock锁机制是不具有锁对象的，因此是不可以去调用notify()、wait()、notifyAll()方法的，否则会发生报错。

### 产生死锁的原因及条件

* 原因
1. 因为系统资源不足。
2. 进程运行推进的顺序不合适。
3. 资源分配不当等。

* 条件
1. 互斥条件：一个资源每次只能被一个进程使用。
2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
3. 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。
4. 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。

### CountDownLatch 原理

CountDownLatch 内部维护了一个整数n，n（要大于等于0）在==当前线程== 初始化CountDownLatch方法指定。当前线程调用 CountDownLatch的await()方法阻塞当前线程，等待其他调用CountDownLatch对象的CountDown()方法的线程执行完毕。 其他线程调用该CountDownLatch的CountDown()方法，该方法会把n-1，直到所有线程执行完成，n等于0，==当前线程==就恢复执行。

### CyclicBarrier 原理

CyclicBarrier简介CyclicBarrier是一个同步辅助类,允许一组线程互相等待,直到到达某个公共屏障点(commonbarrierpoint)。因为该barrier在释放等待线程后可以重用,所以称它为循环的barrier。

### Semaphore 原理

Semaphore直译为信号。实际上Semaphore可以看做是一个信号的集合。不同的线程能够从Semaphore中获取若干个信号量。当Semaphore对象持有的信号量不足时，尝试从Semaphore中获取信号的线程将会阻塞。直到其他线程将信号量释放以后，阻塞的线程会被唤醒，重新尝试获取信号量。

### Exchanger 原理

当一个线程到达exchange调用点时，如果它的伙伴线程此前已经调用了此方法，那么它的伙伴会被调度唤醒并与之进行对象交换，然后各自返回。如果它的伙伴还没到达交换点，那么当前线程将会被挂起，直至伙伴线程到达——完成交换正常返回；或者当前线程被中断——抛出中断异常；又或者是等候超时——抛出超时异常。

### CountDownLatch 与 CyclicBarrier 区别

* CountDownLatch的作用是允许1或N个线程等待其他线程完成执行;而CyclicBarrier则是允许N个线程相互等待。
* CountDownLatch的计数器无法被重置;CyclicBarrier的计数器可以被重置后使用,因此它被称为是循环的barrier。

### ThreadLocal 原理分析

ThreadLocal提供了线程本地变量，它可以保证访问到的变量属于当前线程，每个线程都保存有一个变量副本，每个线程的变量都不同。ThreadLocal相当于提供了一种线程隔离，将变量与线程相绑定。

### 讲讲线程池的实现原理

当提交一个新任务到线程池时，线程池的处理流程如下。

1. 线程池判断核心线程池里的线程是否都在执行任务。如果不是，则创建一个新的工作
线程来执行任务。如果核心线程池里的线程都在执行任务，则进入下个流程。

2. 线程池判断工作队列是否已经满。如果工作队列没有满，则将新提交的任务存储在这
个工作队列里。如果工作队列满了，则进入下个流程。

3. 线程池判断线程池的线程是否都处于工作状态。如果没有，则创建一个新的工作线程
来执行任务。如果已经满了，则交给饱和策略来处理这个任务。

### 线程池的几种方式

1. newFixedThreadPool：创建固定大小的线程池。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。

2. newCachedThreadPool：创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。

3. newSingleThreadExecutor：创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。

4. newScheduledThreadPool：创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。

5. newSingleThreadScheduledExecutor：创建一个单线程的线程池。此线程池支持定时以及周期性执行任务的需求。

### 线程的生命周期

* 新建状态(New): 当程序使用new关键字创建了一个线程后。

* 就绪状态(Runnable): 当线程对象调用了start()方法后，此时虚拟机会为其创建方法调用栈和程序计数器；阻塞线程事件结束后；调用yield()方法让运行状态的线程转入就绪状态。

* 运行状态(Running): 处于就绪状态的线程获得了CPU资源，开始执行run()方法的线程执行体。

* 阻塞状态(Blocked): 线程调用sleep()方法主动放弃所占用的处理器资源；线程调用了一个阻塞式IO方法，在该方法返回之前，该线程被阻塞；线程试图获得一个同步监视器，但该同步监视器正被其他线程所持有；线程在等待某个通知(notify)；程序调用了线程的suspend()方法将该线程挂起(调用resdme()恢复)。

* 死亡状态(Dead): run()或call()方法执行完成，线程正常结束；线程抛出一个未捕获的Exception或Error；直接调用该线程stop()方法来结束该线程。

## 锁

### 说说线程安全问题

线程安全是多线程领域的问题，线程安全可以简单理解为一个方法或者一个实例可以在多线程环境中使用而不会出现问题。
在Java多线程编程当中，提供了多种实现Java线程安全的方式：
最简单的方式，使用Synchronization关键字:Java Synchronization介绍
使用java.util.concurrent.atomic 包中的原子类，例如 AtomicInteger
使用java.util.concurrent.locks 包中的锁
使用线程安全的集合ConcurrentHashMap
使用volatile关键字，保证变量可见性（直接从内存读，而不是从线程cache读）

### volatile 实现原理

* 在JVM底层volatile是采用“内存屏障”来实现的，对编译后的汇编代码增加Lock前缀标记。

Lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面

在每个volatile写操作的前面插入一个StoreStore屏障，后面插入一个StoreLoad屏障。
确保volatile写之前的操作不会被编译器重排序到volatile写之后。
当第一个操作是volatile写，第二个操作是volatile读时，不能重排序。

StoreStore屏障可以保障前面所有的普通写在volatile写之前刷新到主内存

在每个volatile读操作的后面插入一个LoadLoad屏障和一个LoadStore屏障。
确保volatile读之后的操作不会被编译器重排序到volatile读之前。

常见于双重检测单例模式，正常流程为 获取实例地址、完成构造实例、修改单例地址，防止重排序将变量赋予未完成构造的单例地址，从而造成的不安全发布。

* 缓存一致性协议（MESI协议）确保每个缓存中使用的共享变量的副本是一致的。其核心思想如下：当某个CPU在写数据时，如果发现操作的变量是共享变量，则会通知其他CPU告知该变量的缓存行是无效的，因此其他CPU在读取该变量时，发现其无效会重新从主存中加载数据。

### synchronize 实现原理

同步代码块是使用monitorenter和monitorexit指令实现的，同步方法（在这看不出来需要看JVM底层实现）依靠的是方法修饰符上的ACC_SYNCHRONIZED实现。

### synchronized 与 lock 的区别

1. synchronized和lock的用法区别

* synchronized(隐式锁)：在需要同步的对象中加入此控制，synchronized可以加在方法上，也可以加在特定代码块中，括号中表示需要锁的对象。
* lock（显示锁）：需要显示指定起始位置和终止位置。一般使用ReentrantLock类做为锁，多个线程中必须要使用一个ReentrantLock类做为对 象才能保证锁的生效。且在加锁和解锁处需要通过lock()和unlock()显示指出。所以一般会在finally块中写unlock()以防死锁。

2. synchronized和lock性能区别
synchronized是托管给JVM执行的，而lock是java写的控制锁的代码。在Java1.5中，synchronize是性能低效的。因为 这是一个重量级操作，需要调用操作接口，导致有可能加锁消耗的系统时间比加锁以外的操作还多。相比之下使用Java提供的Lock对象，性能更高一些。但 是到了Java1.6，发生了变化。synchronize在语义上很清晰，可以进行很多优化，有适应自旋，锁消除，锁粗化，轻量级锁，偏向锁等等。导致 在Java1.6上synchronize的性能并不比Lock差。

3. synchronized和lock机制区别

* synchronized原始采用的是CPU悲观锁机制，即线程获得的是独占锁。独占锁意味着其 他线程只能依靠阻塞来等待线程释放锁。

* Lock用的是乐观锁方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。乐观锁实现的机制就 是CAS操作（Compare and Swap）。

### CAS 乐观锁

CAS是项乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。
CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值。否则，处理器不做任何操作。无论哪种情况，它都会在 CAS 指令之前返回该位置的值。（在 CAS 的一些特殊情况下将仅返回 CAS 是否成功，而不提取当前值。）CAS 有效地说明了“我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。”这其实和乐观锁的冲突检查+数据更新的原理是一样的。

### ABA 问题

CAS会导致“ABA问题”。
CAS算法实现一个重要前提需要取出内存中某时刻的数据，而在下时刻比较并替换，那么在这个时间差类会导致数据的变化。
比如说一个线程one从内存位置V中取出A，这时候另一个线程two也从内存中取出A，并且two进行了一些操作变成了B，然后two又将V位置的数据变成A，这时候线程one进行CAS操作发现内存中仍然是A，然后one操作成功。尽管线程one的CAS操作成功，但是不代表这个过程就是没有问题的。
部分乐观锁的实现是通过版本号（version）的方式来解决ABA问题，乐观锁每次在执行数据的修改操作时，都会带上一个版本号，一旦版本号和数据的版本号一致就可以执行修改操作并对版本号执行+1操作，否则就执行失败。因为每次操作的版本号都会随之增加，所以不会出现ABA问题，因为版本号只会增加不会减少。

### 乐观锁的业务场景及实现方式

乐观锁（Optimistic Lock）：
每次获取数据的时候，都不会担心数据被修改，所以每次获取数据的时候都不会进行加锁，但是在更新数据的时候需要判断该数据是否被别人修改过。如果数据被其他线程修改，则不进行数据更新，如果数据没有被其他线程修改，则进行数据更新。由于数据没有进行加锁，期间该数据可以被其他线程进行读写操作。
比较适合读取操作比较频繁的场景，如果出现大量的写入操作，数据发生冲突的可能性就会增大，为了保证数据的一致性，应用层需要不断的重新获取数据，这样会增加大量的查询操作，降低了系统的吞吐量。

### 锁，乐观锁，悲观锁，synchronized原理，锁方法和锁对象的区别，锁静态和锁非静态的区别

### synchronzied和可重入锁的区别

## JVM

### Full GC的触发条件

1. 调用System.gc()时，系统建议执行Full GC，但不一定执行

2. 老年代空间不足时

3. 方法区空间不足时

4. 通过Minor GC后进入老年代的平均大小大于老年代的可用内存

5. 由Eden区，From Space区向To Space区复制时，对象大小大于To Space区的可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小

### loadClass 和 Class.forName 有什么不同

* loadClass只进行类的加载

* Class.forName除了进行类加载之外还做了对象的实例化。


### 如何定位线上服务OOM问题

1. 有可能是内存分配确实过小，而正常业务使用了大量内存
比如jmap -heap命令可以查看新生代老年代的堆内存大小及使用情况，看看是否内存本身分配过小。

2. 某一个对象被频繁申请，却没有释放，内存不断泄漏，导致内存耗尽
比如jmap -histo:live 对象显示存活对象的信息，并按照所占内存大小的排序。因为包含了实例数、所占内存大小、类名，所以很直观。

3. 某一个资源被频繁申请，系统资源耗尽，例如：不断创建线程，不断发起网络连接
可以用pstree、netstat查看进程创建线程数，网络连接数，如果资源耗尽，也会出现OOM。也可以查看/proc/${PID}/fd  和/proc/${PID}/task，查看句柄详情和线程数。

## 数据

## 数据存储

### 数据库范式有哪些，具体原理和概念

### mysql默认隔离级别repeated read,介绍一下这个隔离级别相关的一些知识点。

### MySQL 索引使用的注意事项

1. 索引不会包含有NULL的列
只要列中包含有NULL值，都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此符合索引就是无效的。

2. 使用短索引
对串列进行索引，如果可以就应该指定一个前缀长度。例如，如果有一个char（255）的列，如果在前10个或20个字符内，多数值是唯一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作。

3. 索引列排序
mysql查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作，尽量不要包含多个列的排序，如果需要最好给这些列建复合索引。

4. like语句操作
一般情况下不鼓励使用like操作，如果非使用不可，注意正确的使用方式。like ‘%aaa%’不会使用索引，而like ‘aaa%’可以使用索引。

5. 不要在列上进行运算

6. 不使用NOT IN 、<>、！=操作，但<,<=，=，>,>=,BETWEEN,IN是可以用到索引的

7. 索引要建立在经常进行select操作的字段上。
这是因为，如果这些列很少用到，那么有无索引并不能明显改变查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。

8. 索引要建立在值比较唯一的字段上。

9. 对于那些定义为text、image和bit数据类型的列不应该增加索引。因为这些列的数据量要么相当大，要么取值很少。

10. 在where和join中出现的列需要建立索引。

11. where的查询条件里有不等号(where column != …),mysql将无法使用索引。

12. 如果where字句的查询条件里使用了函数(如：where DAY(column)=…),mysql将无法使用索引。

13. 在join操作中(需要从多个数据表提取数据时)，mysql只有在主键和外键的数据类型相同时才能使用索引，否则及时建立了索引也不会使用。

### 说说反模式设计

简单的来说，反模式是指在对经常面对的问题经常使用的低效，不良，或者有待优化的设计模式/方法。甚至，反模式也可以是一种错误的开发思想/理念。在这里我举一个最简单的例子：在面向对象设计/编程中，有一条很重要的原则， 单一责任原则(Single responsibility principle)。其中心思想就是对于一个模块，或者一个类来说，这个模块或者这个类应该只对系统/软件的一个功能负责，而且该责任应该被该类完全封装起来。当开发人员需要修改系统的某个功能，这个模块/类是最主要的修改地方。相对应的一个反模式就是上帝类(God Class)，通常来说，这个类里面控制了很多其他的类，同时也依赖其他很多类。整个类不光负责自己的主要单一功能，而且还负责了其他很多功能，包括一些辅助功能。很多维护老程序的开发人员们可能都遇过这种类，一个类里有几千行的代码，有很多功能，但是责任不明确单一。单元测试程序也变复杂无比。维护/修改这个类的时间要远远超出其他类的时间。很多时候，形成这种情况并不是开发人员故意的。很多情况下主要是由于随着系统的年限，需求的变化，项目的资源压力，项目组人员流动，系统结构的变化而导致某些原先小型的，符合单一原则类慢慢的变的臃肿起来。最后当这个类变成了维护的噩梦(特别是原先熟悉的开发人员离职后)，重构该类就变成了一个不容易的工程。

### 说说分库与分表设计

垂直分表在日常开发和设计中比较常见，通俗的说法叫做“大表拆小表”，拆分是基于关系型数据库中的“列”（字段）进行的。通常情况，某个表中的字段比较多，可以新建立一张“扩展表”，将不经常使用或者长度较大的字段拆分出去放到“扩展表”中。在字段很多的情况下，拆分开确实更便于开发和维护（笔者曾见过某个遗留系统中，一个大表中包含100多列的）。某种意义上也能避免“跨页”的问题（MySQL、MSSQL底层都是通过“数据页”来存储的，“跨页”问题可能会造成额外的性能开销，拆分字段的操作建议在数据库设计阶段就做好。如果是在发展过程中拆分，则需要改写以前的查询语句，会额外带来一定的成本和风险，建议谨慎。
垂直分库在“微服务”盛行的今天已经非常普及了。基本的思路就是按照业务模块来划分出不同的数据库，而不是像早期一样将所有的数据表都放到同一个数据库中。系统层面的“服务化”拆分操作，能够解决业务系统层面的耦合和性能瓶颈，有利于系统的扩展维护。而数据库层面的拆分，道理也是相通的。与服务的“治理”和“降级”机制类似，我们也能对不同业务类型的数据进行“分级”管理、维护、监控、扩展等。
众所周知，数据库往往最容易成为应用系统的瓶颈，而数据库本身属于“有状态”的，相对于Web和应用服务器来讲，是比较难实现“横向扩展”的。数据库的连接资源比较宝贵且单机处理能力也有限，在高并发场景下，垂直分库一定程度上能够突破IO、连接数及单机硬件资源的瓶颈，是大型分布式系统中优化数据库架构的重要手段。
然后，很多人并没有从根本上搞清楚为什么要拆分，也没有掌握拆分的原则和技巧，只是一味的模仿大厂的做法。导致拆分后遇到很多问题（例如：跨库join，分布式事务等）。
水平分表也称为横向分表，比较容易理解，就是将表中不同的数据行按照一定规律分布到不同的数据库表中（这些表保存在同一个数据库中），这样来降低单表数据量，优化查询性能。最常见的方式就是通过主键或者时间等字段进行Hash和取模后拆分。水平分表，能够降低单表的数据量，一定程度上可以缓解查询性能瓶颈。但本质上这些表还保存在同一个库中，所以库级别还是会有IO瓶颈。所以，一般不建议采用这种做法。
水平分库分表与上面讲到的水平分表的思想相同，唯一不同的就是将这些拆分出来的表保存在不同的数据中。这也是很多大型互联网公司所选择的做法。某种意义上来讲，有些系统中使用的“冷热数据分离”（将一些使用较少的历史数据迁移到其他的数据库中。而在业务功能上，通常默认只提供热点数据的查询），也是类似的实践。在高并发和海量数据的场景下，分库分表能够有效缓解单机和单库的性能瓶颈和压力，突破IO、连接数、硬件资源的瓶颈。当然，投入的硬件成本也会更高。同时，这也会带来一些复杂的技术问题和挑战（例如：跨分片的复杂查询，跨分片事务等）。

> http://www.infoq.com/cn/articles/key-steps-and-likely-problems-of-split-table

### 分库与分表带来的分布式困境与应对之策

1. 数据迁移与扩容问题
前面介绍到水平分表策略归纳总结为随机分表和连续分表两种情况。连续分表有可能存在数据热点的问题，有些表可能会被频繁地查询从而造成较大压力，热数据的表就成为了整个库的瓶颈，而有些表可能存的是历史数据，很少需要被查询到。连续分表的另外一个好处在于比较容易，不需要考虑迁移旧的数据，只需要添加分表就可以自动扩容。随机分表的数据相对比较均匀，不容易出现热点和并发访问的瓶颈。但是，分表扩展需要迁移旧的数据。
针对于水平分表的设计至关重要，需要评估中短期内业务的增长速度，对当前的数据量进行容量规划，综合成本因素，推算出大概需要多少分片。对于数据迁移的问题，一般做法是通过程序先读出数据，然后按照指定的分表策略再将数据写入到各个分表中。

2. 表关联问题
在单库单表的情况下，联合查询是非常容易的。但是，随着分库与分表的演变，联合查询就遇到跨库关联和跨表关系问题。在设计之初就应该尽量避免联合查询，可以通过程序中进行拼装，或者通过反范式化设计进行规避。

3. 分页与排序问题
一般情况下，列表分页时需要按照指定字段进行排序。在单库单表的情况下，分页和排序也是非常容易的。但是，随着分库与分表的演变，也会遇到跨库排序和跨表排序问题。为了最终结果的准确性，需要在不同的分表中将数据进行排序并返回，并将不同分表返回的结果集进行汇总和再次排序，最后再返回给用户。

4. 分布式事务问题
随着分库与分表的演变，一定会遇到分布式事务问题，那么如何保证数据的一致性就成为一个必须面对的问题。目前，分布式事务并没有很好的解决方案，难以满足数据强一致性，一般情况下，使存储数据尽可能达到用户一致，保证系统经过一段较短的时间的自我恢复和修正，数据最终达到一致。

5. 分布式全局唯一ID
在单库单表的情况下，直接使用数据库自增特性来生成主键ID，这样确实比较简单。在分库分表的环境中，数据分布在不同的分表上，不能再借助数据库自增长特性。需要使用全局唯一 ID，例如 UUID、GUID等。关于如何选择合适的全局唯一 ID，我会在后面的章节中进行介绍。

> http://blog.csdn.net/jiangpingjiangping/article/details/78069480

### SQL 优化之道

* 一些常见的SQL实践

1. 负向条件查询不能使用索引
select from order where status!=0 and stauts!=1
not in/not exists都不是好习惯
可以优化为in查询：
select from order where status in(2,3)

2. 前导模糊查询不能使用索引
select from order where desc like '%XX'
而非前导模糊查询则可以：
select from order where desc like 'XX%'

3. 数据区分度不大的字段不宜使用索引
select from user where sex=1
原因：性别只有男，女，每次过滤掉的数据很少，不宜使用索引。
经验上，能过滤80%数据时就可以使用索引。对于订单状态，如果状态值很少，不宜使用索引，如果状态值很多，能够过滤大量数据，则应该建立索引。

4. 在属性上进行计算不能命中索引
select from order where YEAR(date) < = '2017'
即使date上建立了索引，也会全表扫描，可优化为值计算：
select from order where date < = CURDATE()
或者：
select from order where date < = '2017-01-01'

* 并非周知的SQL实践

1. 如果业务大部分是单条查询，使用Hash索引性能更好，例如用户中心
select from user where uid=?
select from user where login_name=?
原因：B-Tree索引的时间复杂度是O(log(n))；Hash索引的时间复杂度是O(1)

2. 允许为null的列，查询有潜在大坑
单列索引不存null值，复合索引不存全为null的值，如果列允许为null，可能会得到“不符合预期”的结果集
select from user where name != 'shenjian'
如果name允许为null，索引不存储null值，结果集中不会包含这些记录。
所以，请使用not null约束以及默认值。

3. 复合索引最左前缀，并不是值SQL语句的where顺序要和复合索引一致
用户中心建立了(login_name, passwd)的复合索引
select from user where login_name=? and passwd=?
select from user where passwd=? and login_name=?
都能够命中索引
select from user where login_name=?
也能命中索引，满足复合索引最左前缀
select from user where passwd=?
不能命中索引，不满足复合索引最左前缀

4. 使用ENUM而不是字符串
ENUM保存的是TINYINT，别在枚举中搞一些“中国”“北京”“技术部”这样的字符串，字符串空间又大，效率又低。

* 小众但有用的SQL实践

1. 如果明确知道只有一条结果返回，limit 1能够提高效率
select from user where login_name=?
可以优化为：
select from user where login_name=? limit 1
原因：你知道只有一条结果，但数据库并不知道，明确告诉它，让它主动停止游标移动

2. 把计算放到业务层而不是数据库层，除了节省数据的CPU，还有意想不到的查询缓存优化效果
select from order where date < = CURDATE()
这不是一个好的SQL实践，应该优化为：
$curDate = date('Y-m-d');
$res = mysqlquery(
'select from order where date < = $curDate');
原因：
释放了数据库的CPU
多次调用，传入的SQL相同，才可以利用查询缓存

3. 强制类型转换会全表扫描
select from user where phone=13800001234
你以为会命中phone索引么？大错特错了，这个语句究竟要怎么改？
末了，再加一条，不要使用select *（潜台词，文章的SQL都不合格 ==），只返回需要的列，能够大大的节省数据传输量，与数据库的内存使用量哟。


### MySQL 遇到的死锁问题

产生死锁的四个必要条件：
* 互斥条件：一个资源每次只能被一个进程使用。
* 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
* 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。
* 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。

这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。
下列方法有助于最大限度地降低死锁：
* 按同一顺序访问对象。
* 避免事务中的用户交互。
* 保持事务简短并在一个批处理中。
* 使用低隔离级别。
* 使用绑定连接。

> http://onwise.xyz/2017/04/20/mysql-%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3/

### 存储引擎的 InnoDB 与 MyISAM

1. InnoDB不支持FULLTEXT类型的索引。

2. InnoDB 中不保存表的具体行数，也就是说，执行select count() from table时，InnoDB要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count()语句包含 where条件时，两种表的操作是一样的。

3. 对于AUTO_INCREMENT类型的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中，可以和其他字段一起建立联合索引。

4. DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的删除。
　　
5. LOAD TABLE FROM MASTER操作对InnoDB是不起作用的，解决方法是首先把InnoDB表改成MyISAM表，导入数据后再改成InnoDB表，但是对于使用的额外的InnoDB特性(例如外键)的表不适用。
　　
6. 另外，InnoDB表的行锁也不是绝对的，假如在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表，例如update table set num=1 where name like “%aaa%”

### 数据库索引的原理

数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。

### 为什么要用 B-tree

一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数。

### 聚集索引与非聚集索引的区别

1. 聚集索引一个表只能有一个，而非聚集索引一个表可以存在多个

2. 聚集索引存储记录是物理上连续存在，而非聚集索引是逻辑上的连续，物理存储并不连续

3. 聚集索引:物理存储按照索引排序；聚集索引是一种索引组织形式，索引的键值逻辑顺序决定了表数据行的物理存储顺序
　非聚集索引:物理存储不按照索引排序；非聚集索引则就是普通索引了，仅仅只是对数据列创建相应的索引，不影响整个表的物理存储顺序.

4. 索引是通过二叉树的数据结构来描述的，我们可以这么理解聚簇索引：索引的叶节点就是数据节点。而非聚簇索引的叶节点仍然是索引节点，只不过有一个指针指向对应的数据块。

### 聚集索引和非聚集索引

### 多列索引和单列索引

### 数据库ACID

* 原子性(Automicity)：是指事务必须是一个单元，不可拆分，只存在成功与失败两种状态，任何一个中间环节失败将导致全部失败。

* 一致性(Consistency)：与原子性是相辅相承的，数据在事务的层面上完成前和完成后是两个状态，失败时已经修改的数据需要回退，不能存在数据已经被修改。

* 隔离性(Isolation)：事务与事务之间不会互相影响。

* 持久性(Durability)：操作一旦完成将永久的保存在数据库中。

### limit 20000 加载很慢怎么解决

mysql的性能低是因为数据库要去扫描N+M条记录，然后又要放弃之前N条记录，开销很大
解决思略：
1. 前端加缓存，或者其他方式，减少落到库的查询操作，例如某些系统中数据在搜索引擎中有备份的，可以用es等进行搜索

2. 使用延迟关联，即先通用limit得到需要数据的索引字段，然后再通过原表和索引字段关联获得需要数据
select a.* from a,(select id from table_1 where is_deleted='N' limit 100000,20) b where a.id = b.id

3. 从业务上实现，不分页如此多，例如只能分页前100页，后面的不允许再查了

4. 不使用limit N,M,而是使用limit N，即将offset转化为where条件。

### 选择合适的数据存储方案

#### 关系型数据库 MySQL
MySQL 是一个最流行的关系型数据库，在互联网产品中应用比较广泛。一般情况下，MySQL 数据库是选择的第一方案，基本上有 80% ~ 90% 的场景都是基于 MySQL 数据库的。因为，需要关系型数据库进行管理，此外，业务存在许多事务性的操作，需要保证事务的强一致性。同时，可能还存在一些复杂的 SQL 的查询。值得注意的是，前期尽量减少表的联合查询，便于后期数据量增大的情况下，做数据库的分库分表。

#### 内存数据库 Redis
随着数据量的增长，MySQL 已经满足不了大型互联网类应用的需求。因此，Redis 基于内存存储数据，可以极大的提高查询性能，对产品在架构上很好的补充。例如，为了提高服务端接口的访问速度，尽可能将读频率高的热点数据存放在 Redis 中。这个是非常典型的以空间换时间的策略，使用更多的内存换取 CPU 资源，通过增加系统的内存消耗，来加快程序的运行速度。
在某些场景下，可以充分的利用 Redis 的特性，大大提高效率。这些场景包括缓存，会话缓存，时效性，访问频率，计数器，社交列表，记录用户判定信息，交集、并集和差集，热门列表与排行榜，最新动态等。
使用 Redis 做缓存的时候，需要考虑数据不一致与脏读、缓存更新机制、缓存可用性、缓存服务降级、缓存穿透、缓存预热等缓存使用问题。

#### 文档数据库 MongoDB
MongoDB 是对传统关系型数据库的补充，它非常适合高伸缩性的场景，它是可扩展性的表结构。基于这点，可以将预期范围内，表结构可能会不断扩展的 MySQL 表结构，通过 MongoDB 来存储，这就可以保证表结构的扩展性。
此外，日志系统数据量特别大，如果用 MongoDB 数据库存储这些数据，利用分片集群支持海量数据，同时使用聚集分析和 MapReduce 的能力，是个很好的选择。
MongoDB 还适合存储大尺寸的数据，GridFS 存储方案就是基于 MongoDB 的分布式文件存储系统。

#### 列族数据库 HBase
HBase 适合海量数据的存储与高性能实时查询，它是运行于 HDFS 文件系统之上，并且作为 MapReduce 分布式处理的目标数据库，以支撑离线分析型应用。在数据仓库、数据集市、商业智能等领域发挥了越来越多的作用，在数以千计的企业中支撑着大量的大数据分析场景的应用。

#### 全文搜索引擎 ElasticSearch
在一般情况下，关系型数据库的模糊查询，都是通过 like 的方式进行查询。其中，like “value%” 可以使用索引，但是对于 like “%value%” 这样的方式，执行全表查询，这在数据量小的表，不存在性能问题，但是对于海量数据，全表扫描是非常可怕的事情。ElasticSearch 作为一个建立在全文搜索引擎 Apache Lucene 基础上的实时的分布式搜索和分析引擎，适用于处理实时搜索应用场景。此外，使用 ElasticSearch 全文搜索引擎，还可以支持多词条查询、匹配度与权重、自动联想、拼写纠错等高级功能。因此，可以使用 ElasticSearch 作为关系型数据库全文搜索的功能补充，将要进行全文搜索的数据缓存一份到 ElasticSearch 上，达到处理复杂的业务与提高查询速度的目的。
ElasticSearch 不仅仅适用于搜索场景，还非常适合日志处理与分析的场景。著名的 ELK 日志处理方案，由 ElasticSearch、Logstash 和 Kibana 三个组件组成，包括了日志收集、聚合、多维度查询、可视化显示等。

> http://blog.720ui.com/2017/db_better_db_use/

### 倒排索引

倒排索引（英语：Inverted index），也常被称为反向索引、置入档案或反向档案，是一种索引方法，被用来存储在全文搜索下某个单词在一个文档或者一组文档中的存储位置的映射。它是文档检索系统中最常用的数据结构。
有两种不同的反向索引形式：
一条记录的水平反向索引（或者反向档案索引）包含每个引用单词的文档的列表。
一个单词的水平反向索引（或者完全反向索引）又包含每个单词在一个文档中的位置。

### mysql乐观锁，悲观锁的实现机制。

### ObjectId 规则

[0,1,2,3] [4,5,6] [7,8] [9,10,11]
时间戳 |机器码 |PID |计数器
前四位是时间戳，可以提供秒级别的唯一性。
接下来三位是所在主机的唯一标识符，通常是机器主机名的散列值。
接下来两位是产生ObjectId的PID，确保同一台机器上并发产生的ObjectId是唯一的。
前九位保证了同一秒钟不同机器的不同进程产生的ObjectId时唯一的。
最后三位是自增计数器，确保相同进程同一秒钟产生的ObjectId是唯一的。

> https://github.com/qianjiahao/MongoDB/wiki/MongoDB%E4%B9%8B_id%E7%94%9F%E6%88%90%E8%A7%84%E5%88%99

### MongoDB 使用场景

1. 高伸缩性的场景
MongoDB 非常适合高伸缩性的场景，它是可扩展性的表结构。基于这点，可以将预期范围内，表结构可能会不断扩展的 MySQL 表结构，通过 MongoDB 来存储，这就可以保证表结构的扩展性。

2. 日志系统的场景
日志系统数据量特别大，如果用 MongoDB 数据库存储这些数据，利用分片集群支持海量数据，同时使用聚集分析和 MapReduce 的能力，是个很好的选择。

3. 分布式文件存储
MongoDB 还适合存储大尺寸的数据，之前介绍的 GridFS 存储方案，就是基于 MongoDB 的分布式文件存储系统。

> http://blog.720ui.com/2017/mongodb_core_use/

### redis为什么是单线程的？请说出底层原理

### redis sortedSet底层实现及其原理。

### ElasticSearch 使用场景

全文搜索，这个是用的最多的。加上分词插件、拼音插件什么的可以做成强大的全文搜索引擎。
数据库，挺奇葩的用法，因为ES存数相同数据，更费空间，不过确实不错，因为他的强大统计分析汇总能力，再加上分布式P2P扩展能力，现在硬件又那么便宜，所以就有人拿来当数据库了。
在线统计分析引擎，日志系统。logstash，不用解释了吧。可以实时动态分析数据，很是爽。

## 缓存

### Redis 有哪些类型

在Redis中有五种数据类型:

* String----------字符串
* Hash------------字典
* List-------------列表
* Set--------------集合
* Sorted Set------有序集合

### Redis 内部结构

Redis 内部使用一个 redisObject 对象来表示所有的 key 和 value。type ：代表一个 value 对象具体是何种数据类型。
encoding ：是不同数据类型在 redis 内部的存储方式，比如：type=string 代表 value 存储的是一个普通字符串，那么对应的 encoding 可以是 raw 或者是 int，如果是 int 则代表实际 redis 内部是按数值型类存储和表示这个字符串的，当然前提是这个字符串本身可以用数值表示，比如："123" "456"这样的字符串。
vm 字段：只有打开了 Redis 的虚拟内存功能，此字段才会真正的分配内存，该功能默认是关闭状态的。 Redis 使用 redisObject 来表示所有的 key/value 数据是比较浪费内存的，当然这些内存管理成本的付出主要也是为了给 Redis 不同数据类型提供一个统一的管理接口，实际作者也提供了多种方法帮助我们尽量节省内存使用。

> https://www.jianshu.com/p/f09480c05e42

### Redis 使用场景

* 缓存
* 会话缓存
* 时效性
* 访问频率
* 计数器
* 社交列表
* 记录用户判定信息
* 交集、并集和差集
* 热门列表与排行榜
* 最新动态
* 消息队列

> http://blog.720ui.com/2017/redis_core_use/

### Redis 持久化机制

redis有两种持久化机制RDB与AOF。

> http://shanks.leanote.com/post/Untitled-55ca439338f41148cd000759-22

### Redis 如何实现持久化

RDB持久化方式会在一个特定的间隔保存那个时间点的一个数据快照。
AOF持久化方式则会记录每一个服务器收到的写操作。在服务启动时，这些记录的操作会逐条执行从而重建出原来的数据。写操作命令记录的格式跟Redis协议一致，以追加的方式进行保存。
Redis的持久化是可以禁用的，就是说你可以让数据的生命周期只存在于服务器的运行时间里。
两种方式的持久化是可以同时存在的，但是当Redis重启时，AOF文件会被优先用于重建数据。

### Redis 集群方案与实现

客户端分片
基于代理的分片
路由查询
客户端分片
由客户端决定key写入或者读取的节点。
包括jedis在内的一些客户端，实现了客户端分片机制。

路由查询
将请求发送到任意节点，接收到请求的节点会将查询请求发送到正确的节点上执行。
开源方案

### Redis 为什么是单线程的

因为CPU不是Redis的瓶颈。Redis的瓶颈最有可能是机器内存或者网络带宽。（以上主要来自官方FAQ）既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。

### redis缓存实时更新问题

### 缓存奔溃

1. 碰到这种情况，一般并发量不是特别多的时候，使用最多的解决方案是加锁排队。
2. 加锁排队只是为了减轻数据库的压力，并没有提高系统吞吐量。假设在高并发下，缓存重建期间key是锁着的，这是过来1000个请求999个都在阻塞的。同样会导致用户等待超时，这是个治标不治本的方法。

### 缓存降级

页面降级：在大促或者某些特殊情况下，某些页面占用了一些稀缺服务资源，在紧急情况下可以对其整个降级，以达到丢卒保帅；
页面片段降级：比如商品详情页中的商家部分因为数据错误了，此时需要对其进行降级；
页面异步请求降级：比如商品详情页上有推荐信息/配送至等异步加载的请求，如果这些信息响应慢或者后端服务有问题，可以进行降级；
服务功能降级：比如渲染商品详情页时需要调用一些不太重要的服务：相关分类、热销榜等，而这些服务在异常情况下直接不获取，即降级即可；
读降级：比如多级缓存模式，如果后端服务有问题，可以降级为只读缓存，这种方式适用于对读一致性要求不高的场景；
写降级：比如秒杀抢购，我们可以只进行Cache的更新，然后异步同步扣减库存到DB，保证最终一致性即可，此时可以将DB降级为Cache。
爬虫降级：在大促活动时，可以将爬虫流量导向静态页或者返回空数据，从而保护后端稀缺资源。
自动开关降级
自动降级是根据系统负载、资源使用情况、SLA等指标进行降级。
超时降级
当访问的数据库/http服务/远程调用响应慢或者长时间响应慢，且该服务不是核心服务的话可以在超时后自动降级；比如商品详情页上有推荐内容/评价，但是推荐内容/评价暂时不展示对用户购物流程不会产生很大的影响；对于这种服务是可以超时降级的。如果是调用别人的远程服务，和对方定义一个服务响应最大时间，如果超时了则自动降级。

> http://jinnianshilongnian.iteye.com/blog/2306477

### 使用缓存的合理性问题

热点数据，缓存才有价值
频繁修改的数据，看情况考虑使用缓存
数据不一致性
缓存更新机制
缓存可用性
缓存服务降级
缓存预热
缓存穿透

> http://blog.720ui.com/2016/redis_action_01_use_core/

## 消息队列

### 消息队列的使用场景

校验用户名等信息，如果没问题会在数据库中添加一个用户记录
如果是用邮箱注册会给你发送一封注册成功的邮件，手机注册则会发送一条短信
分析用户的个人信息，以便将来向他推荐一些志同道合的人，或向那些人推荐他
发送给用户一个包含操作指南的系统通知

### 消息的重发补偿解决思路

可靠消息服务定时查询状态为已发送并超时的消息
可靠消息将消息重新投递到 MQ 组件中
下游应用监听消息，在满足幂等性的条件下，重新执行业务。
下游应用通知可靠消息服务该消息已经成功消费。
通过消息状态确认和消息重发两个功能，可以确保上游应用、可靠消息服务和下游应用数据的最终一致性。


### 消息的幂等性解决思路

* 查询操作
查询一次和查询多次，在数据不变的情况下，查询结果是一样的。select是天然的幂等操作

* 删除操作
删除操作也是幂等的，删除一次和多次删除都是把数据删除。(注意可能返回结果不一样，删除的数据不存在，返回0，删除的数据多条，返回结果多个)

* 唯一索引，防止新增脏数据
比如：支付宝的资金账户，支付宝也有用户账户，每个用户只能有一个资金账户，怎么防止给用户创建资金账户多个，那么给资金账户表中的用户ID加唯一索引，所以一个用户新增成功一个资金账户记录

* token机制，防止页面重复提交

* 悲观锁
获取数据的时候加锁获取
select * from table_xxx where id='xxx' for update;
注意：id字段一定是主键或者唯一索引，不然是锁表，会死人的
悲观锁使用时一般伴随事务一起使用，数据锁定时间可能会很长，根据实际情况选用

* 乐观锁
乐观锁只是在更新数据那一刻锁表，其他时间不锁表，所以相对于悲观锁，效率更高。

* 分布式锁
还是拿插入数据的例子，如果是分布是系统，构建全局唯一索引比较困难，例如唯一性的字段没法确定，这时候可以引入分布式锁，通过第三方的系统(redis或zookeeper)，在业务系统插入数据或者更新数据，获取分布式锁，然后做操作，之后释放锁，这样其实是把多线程并发的锁的思路，引入多多个系统，也就是分布式系统中得解决思路。
select + insert
并发不高的后台系统，或者一些任务JOB，为了支持幂等，支持重复执行，简单的处理方法是，先查询下一些关键数据，判断是否已经执行过，在进行业务处理，就可以了
注意：核心高并发流程不要用这种方法

* 状态机幂等
在设计单据相关的业务，或者是任务相关的业务，肯定会涉及到状态机(状态变更图)，就是业务单据上面有个状态，状态在不同的情况下会发生变更，一般情况下存在有限状态机，这时候，如果状态机已经处于下一个状态，这时候来了一个上一个状态的变更，理论上是不能够变更的，这样的话，保证了有限状态机的幂等。

* 对外提供接口的api如何保证幂等
如银联提供的付款接口：需要接入商户提交付款请求时附带：source来源，seq序列号
source+seq在数据库里面做唯一索引，防止多次付款，(并发时，只能处理一个请求)

> http://825635381.iteye.com/blog/2276077

### 消息的堆积解决思路

如果还没开始投入使用kafka，那应该在设计分区数的时候，尽量设置的多点（当然也不要太大，太大影响延迟，具体可以参考我前面提到的文章），从而提升生产和消费的并行度，避免消费太慢导致消费堆积。
增大批次
瓶颈在消费吞吐量的时候，增加批次也可以改善性能
增加线程数
如果一些消费者组中的消费者线程还是有1个消费者线程消费多个分区的情况，建议增加消费者线程。尽量1个消费者线程对应1个分区，从而发挥现有分区数下的最大并行度。

> https://kaimingwan.com/post/framworks/kafka/kafkaxiao-xi-dui-ji-chu-li

### 自己如何实现消息队列

大体上的设计是由一条线程1执行从等待列表中获取任务插入任务队列再由线程池中的线程从任务队列中取出任务去执行.
添加一条线程1主要是防止在执行耗时的任务时阻塞主线程.当执行耗时任务时,添加的任务的操作快于取出任务的操作,
当任务队列长度达到最大值时,线程1将被阻塞,等待线程2,3...从任务队列取出任务执行。

> https://www.jianshu.com/p/2d2271ecc64d

### 如何保证消息的有序性

通过轮询所有队列的方式来确定消息被发送到哪一个队列（负载均衡策略）。订单号相同的消息会被先后发送到同一个队列中，
在获取到路由信息以后，会根据算法来选择一个队列，同一个OrderId获取到的肯定是同一个队列。

# 框架

## Spring

### BeanFactory 和 ApplicationContext 有什么区别
### Spring Bean 的生命周期
### Spring IOC 如何实现
### Spring AOP 实现原理
### 动态代理（cglib 与 JDK）
### Spring 事务实现方式
### Spring 事务底层原理
### 如何自定义注解实现功能
### Spring MVC 运行流程
### Spring MVC 启动流程
### Spring 的单例实现原理
### Spring 框架中用到了哪些设计模式
### Spring 其他产品（Srping Boot、Spring Cloud、Spring Secuirity、Spring Data、Spring AMQP 等）
### SpringMvc和SpringBoot的区别
### spring boot 加载原理
### spring加载原理
### Spring IOC原理及其具体实现
### spring 事物相关问题

### mybatis怎么实现乐观锁，悲观锁

## Netty

### 为什么选择 Netty
### 说说业务中，Netty 的使用场景
### 原生的 NIO 在 JDK 1.7 版本存在 epoll bug
### 什么是TCP 粘包/拆包
### TCP粘包/拆包的解决办法
### Netty 线程模型
### Netty 的零拷贝
### Netty 内部执行流程
### Netty 重连实现

# 微服务

## 概念

### 前后端分离是如何做的

在前后端分离架构中，后端只需要负责按照约定的数据格式向前端提供可调用的API服务即可。前后端之间通过HTTP请求进行交互，前端获取到数据后，进行页面的组装和渲染，最终返回给浏览器。

### 如何解决跨域

1. JSONP（废弃）
很早很早之前，我有个项目曾经使用过JSONP处理跨域问题。简单的理解，jsonp是带有回调函数callback的json，它是一个很棒的方案，可用于解决主流浏览器的跨域数据访问的问题。但是，JSONP方案的局限性在于，JSONP只能实现GET请求。随着现在RESTful的兴起，JSONP显得力不从心了。因为，RESTful不仅有GET，还存在POST、PUT、PATCH、DELETE。

2. CORS（常用）
CORS 全称为 Cross Origin Resource Sharing（跨域资源共享）。整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，但用户不会有感觉。因此，实现CORS通信的关键是服务端。服务端只需添加相关响应头信息，即可实现客户端发出 AJAX 跨域请求。

值得注意的是，浏览器必须先以 OPTIONS 请求方式发送一个预请求，从而获知服务器端对跨源请求所支持 HTTP 方法。在确认服务器允许该跨源请求的情况下，以实际的 HTTP 请求方法发送那个真正的请求。

我们绝大多数项目采取这个方案，实现细节，不再扩展，如果有疑问，可以关注公众号私信，或者评论留言哟。

但是，不幸的是，CORS不支持IE8、IE9，如果产品不再考虑兼容IE低版本的话，可以忽略，但是如果产品需要兼容目前国内还存在大量低版本的IE市场（百分之二十多），那么这个需要慎重考虑咯。


3. 搭建中间转发层（常用）
跨域问题的核心是什么？不同源访问。是啊，如果我们转换成同源请求，就不存在这个问题啦。

因此，我们之前有个项目，通过搭建中间层，当然可以是java，也可以是node.js，通过将服务端的请求进行转发，换句话说，就是dispatcher了一层，那么前端请求的地址，就被转发了，所以很好的解决跨域问题。

当然，如果对性能有考量的产品，就需要慎重选择这个方案咯，因为多了一层中间转发，不管是网络开销，还是性能负载都是有一定的影响。

4. Nginx反向代理（常用）
首先，产品需要搭建一个中转nginx服务器，用于转发请求。当然，我们都是基于Nginx作为反向代理，所以当然是水到渠成。

那么，Nginx的思路，就是通过Nginx解析URL地址的时候进行判断，将请求转发的具体的服务器上。

### 微服务哪些框架
Dubbo、SpringCloud、gPRC、baidu-rpc、Motan

### 你怎么理解 RPC 框架

> https://www.zhihu.com/question/25536695

### RPC相关概念及其的实现原理

首先需要有处理网络连接通讯的模块，负责连接建立、管理和消息的传输。其次需要有编解码的模块，因为网络通讯都是传输的字节码，需要将我们使用的对象序列化和反序列化。剩下的就是客户端和服务器端的部分，服务器端暴露要开放的服务接口，客户调用服务接口的一个代理实现，这个代理实现负责收集数据、编码并传输给服务器然后等待结果返回。

> https://liuzhengyang.github.io/2016/12/16/rpc-principle/

### RPC HTTP,Socket区别
### 说说 Dubbo 的实现原理

例如dubbo作为rpc框架，实现的效果就是调用远程的方法就像在本地调用一样。如何做到呢？就是本地有对远程方法的描述，包括方法名、参数、返回值，在dubbo中是远程和本地使用同样的接口；然后呢，要有对网络通信的封装，要对调用方来说通信细节是完全不可见的，网络通信要做的就是将调用方法的属性通过一定的协议（简单来说就是消息格式）传递到服务端；服务端按照协议解析出调用的信息；执行相应的方法；在将方法的返回值通过协议传递给客户端；客户端再解析；在调用方式上又可以分为同步调用和异步调用；简单来说基本就这个过程
> https://www.zhihu.com/question/52133065/answer/129153953

### 怎么理解 RESTful

> http://www.cnblogs.com/artech/p/3506553.html

### 如何设计一个良好的 API

> https://juejin.im/entry/59b8d34c6fb9a00a4455dd04

### 如何理解 RESTful API 的幂等性

> http://blog.720ui.com/2016/restful_idempotent/

### 如何保证接口的幂等性

> http://www.spring4all.com/article/914

### 说说 CAP 定理、 BASE 理论

> http://my.oschina.net/foodon/blog/372703

### 怎么考虑数据一致性问题

> https://opentalk.upyun.com/310.html

### 说说最终一致性的实现方案

> http://www.cnblogs.com/soundcode/p/5590710.html

### 你怎么看待微服务

> http://dockone.io/article/394

### 微服务与 SOA 的区别

> http://dockone.io/article/2399

### 如何拆分服务

> http://dockone.io/article/2516

### 微服务如何进行数据库管理

> http://www.uml.org.cn/wfw/201705271.asp

### 如何应对微服务的链式调用异常

> http://blog.720ui.com/2017/msa_design/?utm_source=tuicool&utm_medium=referral

### 对于快速追踪与定位问题

依赖日志与监控

### 微服务的安全

> http://dockone.io/article/1507

## 分布式

### 使用分布式的场景

> https://segmentfault.com/q/1010000006095431/a-1020000006114658

### Session 分布式方案

1. Session复制
在支持Session复制的Web服务器上，通过修改Web服务器的配置，可以实现将Session同步到其它Web服务器上，达到每个Web服务器上都保存一致的Session。
优点：代码上不需要做支持和修改。
缺点：需要依赖支持的Web服务器，一旦更换成不支持的Web服务器就不能使用了，在数据量很大的情况下不仅占用网络资源，而且会导致延迟。
适用场景：只适用于Web服务器比较少且Session数据量少的情况。
可用方案：开源方案tomcat-redis-session-manager，暂不支持Tomcat8。

2. Session粘滞
将用户的每次请求都通过某种方法强制分发到某一个Web服务器上，只要这个Web服务器上存储了对应Session数据，就可以实现会话跟踪。
优点：使用简单，没有额外开销。
缺点：一旦某个Web服务器重启或宕机，相对应的Session数据将会丢失，而且需要依赖负载均衡机制。
适用场景：对稳定性要求不是很高的业务情景。

3. Session集中管理
在单独的服务器或服务器集群上使用缓存技术，如Redis存储Session数据，集中管理所有的Session，所有的Web服务器都从这个存储介质中存取对应的Session，实现Session共享。
优点：可靠性高，减少Web服务器的资源开销。
缺点：实现上有些复杂，配置较多。
适用场景：Web服务器较多、要求高可用性的情况。
可用方案：开源方案Spring Session，也可以自己实现，主要是重写HttpServletRequestWrapper中的getSession方法，博主也动手写了一个，github搜索joincat用户，然后自取。

4. 基于Cookie管理
这种方式每次发起请求的时候都需要将Session数据放到Cookie中传递给服务端。
优点：不需要依赖额外外部存储，不需要额外配置。
缺点：不安全，易被盗取或篡改；Cookie数量和长度有限制，需要消耗更多网络带宽。
适用场景：数据不重要、不敏感且数据量小的情况。

5. 总结
这四种方式，相对来说，Session集中管理更加可靠，使用也是最多的。

> https://www.jianshu.com/p/3dd4e06bdfa4
> https://yq.aliyun.com/articles/387723

### 分布式锁的场景

> https://yq.aliyun.com/articles/465311

### 分布式锁的实现方案

> https://yq.aliyun.com/articles/60663

### 分布式事务

> http://www.hollischuang.com/archives/681

### 集群与负载均衡的算法与实现

> https://yq.aliyun.com/articles/218895

### 分库与分表设计

> http://blog.720ui.com/2017/mysql_core_08_multi_db_table/

### 分库与分表带来的分布式困境与应对之策

> http://blog.720ui.com/2017/mysql_core_09_multi_db_table2/

## 安全

### 安全要素与 STRIDE 威胁

> http://blog.720ui.com/2017/security_stride/

### 防范常见的 Web 攻击

> http://blog.720ui.com/2016/security_web/

### 服务端通信安全攻防

> http://blog.720ui.com/2016/security_data_transmission/

### HTTPS 原理剖析

> http://blog.720ui.com/2016/security_https/

### HTTPS 降级攻击

> http://blog.jobbole.com/106792/

### 授权与认证

> https://www.jianshu.com/p/cda95dff698c

### 基于角色的访问控制

> https://www.douban.com/note/259930498/

### 基于数据的访问控制

> https://www.zhihu.com/question/64888533

## 性能优化

### 性能指标有哪些

> https://www.douban.com/note/168911628/

### 如何发现性能瓶颈

> http://blog.csdn.net/shan9liang/article/details/24035001

### 性能调优的常见手段

> http://blog.csdn.net/jyonghu003/article/details/70055832

### 说说你在项目中如何进行性能调优

> https://www.jianshu.com/p/08d029607b9a

# 工程

## 需求分析

### 你如何对需求原型进行理解和拆分
### 说说你对功能性需求的理解
### 说说你对非功能性需求的理解
### 你针对产品提出哪些交互和改进意见
### 你如何理解用户痛点

## 设计能力

### 说说你在项目中使用过的 UML 图
### 你如何考虑组件化
### 你如何考虑服务化
### 你如何进行领域建模
### 你如何划分领域边界
### 说说你项目中的领域建模
### 说说概要设计

## 设计模式

### 你项目中有使用哪些设计模式
### 说说常用开源框架中设计模式使用分析
### 说说你对设计原则的理解
### 23种设计模式的设计理念
### 设计模式之间的异同，例如策略模式与状态模式的区别
### 设计模式之间的结合，例如策略模式+简单工厂模式的实践
### 设计模式的性能，例如单例模式哪种性能更好。

### 怎么才能设计一个高QPS的接口
### 秒杀怎么设计
### 什么是工厂模式，工厂模式的具体应用场景是什么？
### 如果有一个非常长的数组，其中有一个左括号，在数组的右边有一个右括号进行匹配，如果匹配成功，那么继续。如果匹配不成功，就记录下来。求第一次匹配不成功的数组的下标，如果匹配不成功，也继续，直到整个数组遍历完毕，求：有多少对括号不匹配。

## 业务工程 

### 你系统中的前后端分离是如何做的
### 说说你的开发流程
### 你和团队是如何沟通的
### 你如何进行代码评审
### 说说你对技术与业务的理解
### 说说你在项目中经常遇到的 Exception
### 说说你在项目中遇到感觉最难Bug，怎么解决的
### 说说你在项目中遇到印象最深困难，怎么解决的
### 你觉得你们项目还有哪些不足的地方
### 你是否遇到过 CPU 100% ，如何排查与解决
### 你是否遇到过 内存 OOM ，如何排查与解决
### 说说你对敏捷开发的实践
### 说说你对开发运维的实践
### 介绍下工作中的一个对自己最有价值的项目，以及在这个过程中的角色

# 操作系统

## 存储

### 典型PC系统各种操作指令的大概时间
### 执行基本指令(execute typical instruction)
### 从一级缓存中读取数据
### 分支误预测(branch misprediction)
### 从二级缓存获取数据
### 互斥加锁/解锁(Mutex lock/unlock)
### 从主内存获取数据(fetch from main memory)
### 从内存中顺序读取1MB数据
### 从新的磁盘位置获取数据（随机读取）
### 从磁盘中顺序读取1MB数据

### 进程、线程、管程、协程、纤程、例程的区别
1. 进程是资源分配的最小单元，线程是任务调度的最小单元。

2. 线程是为了解决进程在IO处理时对CPU资源的浪费而诞生的，采取先占式多任务。

3. 管程保证了同一时刻只有一个进程在管程内活动。

4. [纤程](https://zh.wikipedia.org/zh-cn/%E7%BA%96%E7%A8%8B)(Fiber)是一种用户态轻量线程，为了解决进程间或线程间的上下文切换的开销而产生的，采取合作式多任务，切换比内核级线程要小得多。
纤程可以由程序或线程库来调度，也可以通过纤程启用额外的纤程。

5. 例程是把一段相对独立的代码写成单独的一个模块，就是传统上函数的概念。

6. [协程](https://zh.wikipedia.org/wiki/%E5%8D%8F%E7%A8%8B)(Coroutine)相对于例程，可以有多个入口和出口点。
协程属于用户态，其上下文数据在调用结束前始终存在，在控制离开时暂停执行，将线程的执行上下文改成你要执行的代码，当控制再次进入时只能从离开的位置继续执行，如python的yield命令
。
> https://blog.csdn.net/hyman_yx/article/details/52251261

7. 进程之间的串行运行的，线程之间是并行运行的。 

> https://softwareengineering.stackexchange.com/questions/254140/is-there-a-difference-between-fibers-coroutines-and-green-threads-and-if-that-i

## 网络

### Session 与 Cookie 区别

1. cookie数据存放在客户的浏览器上，session数据放在服务器上。

2. cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗
考虑到安全应当使用session。

3. session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能
考虑到减轻服务器性能方面，应当使用COOKIE。

4. 单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。

5. 所以个人建议：
将登陆信息等重要信息存放为SESSION
其他信息如果需要保留，可以放在COOKIE中

### HTTP 请求的 GET 与 POST 方式的区别

1. 根据HTTP规范，GET用于信息获取，而且应该是安全的和幂等的。

2. 根据HTTP规范，POST表示可能修改变服务器上的资源的请求。

3. 首先是"GET方式提交的数据最多只能是1024字节"，因为GET是通过URL提交数据，那么GET可提交的数据量就跟URL的长度有直接关系了。而实际上，URL不存在参数上限的问题，HTTP协议规范没有对URL长度进行限制。这个限制是特定的浏览器及服务器对它的限制。

### HTTP三次握手
### 通过1G bps 的网络发送2K字节
### 从美国发送一个报文包到欧洲再返回

# 其他

### 说说你的亮点
### 说说你最近在看什么书
### 说说你觉得最有意义的技术书籍
### 工作之余做什么事情
### 说说个人发展方向方面的思考
### 说说你认为的服务端开发工程师应该具备哪些能力
### 说说你认为的架构师是什么样的，架构师主要做什么
### 说说你所理解的技术专家
